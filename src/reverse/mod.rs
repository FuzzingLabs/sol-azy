//! Static analysis and reverse engineering for Solana eBPF programs.
//!
//! This module provides functionality to disassemble compiled bytecode, generate control flow graphs,
//! and track immediate values from read-only memory segments.
//!
//! It includes:
//! - [`mod@cfg`] — CFG generation and `.dot` export based on instruction analysis.
//! - [`disass`] — Disassembler with immediate tracking support.
//! - [`immediate_tracker`] — Tracks offset ranges for immediate data.
//! - [`utils`] — Low-level utilities used by the analysis engine.
//!
//! The main entry point is [`analyze_program`], which drives the analysis based on the selected output mode.

pub mod cfg;
pub mod disass;
pub mod rusteq;
pub mod immediate_tracker;
pub mod utils;

use cfg::*;
use disass::disassemble_wrapper;
use immediate_tracker::ImmediateTracker;
use indicatif::{ProgressBar, ProgressStyle};
use log::{debug, error};
use solana_sbpf::{
    ebpf::MM_RODATA_START,
    elf::Executable,
    program::BuiltinProgram,
    static_analysis::Analysis,
    vm::Config,
};
use std::{fs::File, io::Read as _, path::Path, sync::Arc, time::Duration};
use test_utils::TestContextObject;

use anyhow::Result;

/// Represents the different types of output files that can be generated by the analysis.
pub enum OutputFile {
    Disassembly,
    ImmediateDataTable,
    Cfg,
}

/// Returns the default filename associated with each type of output file.
impl OutputFile {
    pub fn default_filename(&self) -> &'static str {
        match self {
            OutputFile::Disassembly => "disassembly.out",
            OutputFile::ImmediateDataTable => "immediate_data_table.out",
            OutputFile::Cfg => "cfg.dot",
        }
    }
}

/// Defines the output mode for the analysis process.
pub enum ReverseOutputMode {
    /// Only disassemble the program and generate `immediate_data_table` and `disassembly` files.
    Disassembly(String),
    /// Generate a control flow graph and export it as a `.dot` file.
    ControlFlowGraph(String),
    /// Perform both disassembly and CFG generation.
    DisassemblyAndCFG(String),
}

impl ReverseOutputMode {
    /// Retrieves the associated path string for the selected output mode.
    pub fn path(&self) -> &str {
        match self {
            ReverseOutputMode::Disassembly(p)
            | ReverseOutputMode::ControlFlowGraph(p)
            | ReverseOutputMode::DisassemblyAndCFG(p) => p,
        }
    }
}

/// Analyzes a compiled eBPF program and generates output depending on the selected `ReverseOutputMode`.
///
/// This function supports optional configurations to reduce the complexity of the generated Control Flow Graph (CFG),
/// or to restrict the output to only the entrypoint function for manual extension via tools like `dotting`.
///
/// # Parameters
///
/// * `mode` - Output mode that determines the type of reverse engineering output to generate (disassembly, CFG, both, or rust equivalent).
/// * `target_bytecode` - Path to the ELF binary of the eBPF program.
/// * `labeling` - Enables symbol and section labeling if `true`. Useful for better disassembly readability.
/// * `reduced` - If `true`, only includes functions defined after the program's entrypoint in the generated CFG, 
///   omitting system-level or library-defined functions that may not be relevant.
/// * `only_entrypoint` - If `true`, generates a CFG containing only the entrypoint (`cluster_{entry}`) block,
///   allowing users to build out a focused CFG incrementally (e.g., with the `dotting` module).
///
/// # Returns
///
/// * `Ok(())` if analysis and output generation completed successfully.
/// * `Err(anyhow::Error)` if parsing, analysis, or file writing*
pub fn analyze_program(
    mode: ReverseOutputMode,
    target_bytecode: String,
    labeling: bool,
    reduced: bool,
    only_entrypoint: bool,
) -> Result<()> {
    // Mocking a loader & create an executable
    let loader = Arc::new(BuiltinProgram::new_loader(Config {
        enable_instruction_tracing: true,
        enable_symbol_and_section_labels: labeling,
        ..Config::default()
    }));
    let mut file = File::open(Path::new(&target_bytecode)).unwrap();
    let mut elf = Vec::new();
    file.read_to_end(&mut elf).unwrap();
    let program = elf.clone();
    let executable = match Executable::<TestContextObject>::from_elf(&elf, loader) {
        Ok(executable) => executable,
        Err(err) => {
            error!("Executable constructor failed: {:?}", err);
            if labeling {
                debug!("Hint: Try disabling '--labeling' if your binary is not stripped properly (e.g., contains unexpected symbols).");
            }
            return Err(anyhow::anyhow!("Failed to construct executable: {:?}", err));
        }
    };

    let spinner = ProgressBar::new_spinner();
    spinner.set_message("Performing binary analysis...");
    spinner.set_style(ProgressStyle::default_spinner()
        .tick_strings(&["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"])
        .template("{spinner} {msg}")
        .unwrap());
    spinner.enable_steady_tick(Duration::from_millis(50));

    // Perform analysis on the executable (e.g., necessary for disassembly, control flow graph, etc..).
    let mut analysis = Analysis::from_executable(&executable).unwrap();

    spinner.finish_using_style();

    // Used to track all immediate datas in order to create a table with their possible associated values
    let mut imm_tracker = ImmediateTracker::new(program.len() + MM_RODATA_START as usize);
    let imm_tracker_wrapped = Some(&mut imm_tracker);

    match mode {
        ReverseOutputMode::Disassembly(path) => {
            let _ = disassemble_wrapper(&program, &mut analysis, imm_tracker_wrapped, &path);
        }
        ReverseOutputMode::ControlFlowGraph(path) => {
            export_cfg_to_dot(&program, &mut analysis, &path, reduced, only_entrypoint)?;
        }
        ReverseOutputMode::DisassemblyAndCFG(path) => {
            let _ = disassemble_wrapper(&program, &mut analysis, imm_tracker_wrapped, &path);
            export_cfg_to_dot(&program, &mut analysis, &path, reduced, only_entrypoint)?;
        }
    }
    Ok(())
}

/// Integration tests for the `analyze_program` function using real bytecode inputs.
#[cfg(test)]
mod tests {
    use super::*;

    /// Tests disassembly and CFG generation on a standard bytecode.
    #[test]
    fn test() {
        let _ = analyze_program(
            ReverseOutputMode::DisassemblyAndCFG(
                "test_cases/base_sbf_addition_checker/out1/".to_string(),
            ),
            "test_cases/base_sbf_addition_checker/bytecodes/addition_checker.so".to_string(),
            true,
            false,
            false
        );
    }

    /// Tests disassembly and CFG generation on a SBF program.
    #[test]
    fn test2() {
        let _ = analyze_program(
            ReverseOutputMode::DisassemblyAndCFG(
                "test_cases/base_sbf_addition_checker/out2/".to_string(),
            ),
            "test_cases/base_sbf_addition_checker/bytecodes/addition_checker_sbpf_solana.so"
                .to_string(),
            false,
            false,
            false
        );
    }
}
