pub mod cfg;
pub mod disass;
pub mod immediate_tracker;
pub mod utils;

use cfg::*;

use disass::disassemble_wrapper;
use immediate_tracker::ImmediateTracker;
use solana_sbpf::{
    elf::Executable,
    program::{BuiltinProgram, FunctionRegistry, SBPFVersion},
    static_analysis::Analysis, vm::Config,
};
use std::{fs::File, io::Read as _, path::Path, sync::Arc, u8};
use test_utils::TestContextObject;

use anyhow::Result;

/// Represents the different types of output files that can be generated by the analysis.
pub enum OutputFile {
    Disassembly,
    ImmediateDataTable,
    Cfg,
}

/// Returns the default filename associated with each type of output file.
impl OutputFile {
    pub fn default_filename(&self) -> &'static str {
        match self {
            OutputFile::Disassembly => "disassembly.out",
            OutputFile::ImmediateDataTable => "immediate_data_table.out",
            OutputFile::Cfg => "cfg.dot",
        }
    }
}

/// Defines the output mode for the analysis process.
pub enum ReverseOutputMode {
    /// Only disassemble the program and generate `immediate_data_table` and `disassembly` files.
    Disassembly(String),
    /// Generate a control flow graph and export it as a `.dot` file.
    ControlFlowGraph(String),
    /// Perform both disassembly and CFG generation.
    DisassemblyAndCFG(String),
    /// Reserved for future use: disassembly and a Rust-like source code output.
    DisassAndRustEquivalent(String),
}

impl ReverseOutputMode {
    /// Retrieves the associated path string for the selected output mode.
    pub fn path(&self) -> &str {
        match self {
            ReverseOutputMode::Disassembly(p)
            | ReverseOutputMode::ControlFlowGraph(p)
            | ReverseOutputMode::DisassemblyAndCFG(p)
            | ReverseOutputMode::DisassAndRustEquivalent(p) => p,
        }
    }
}


/// Analyzes a compiled eBPF program and generates output depending on the selected `ReverseOutputMode`.
///
/// # Parameters
///
/// * `mode` - Output mode to determine what kind of results to generate.
/// * `target_bytecode` - Path to the ELF binary of the eBPF program.
/// * `labeling` - Enables symbol and section labeling if `true`.
///
/// # Returns
///
/// `Ok(())` on success, or an error if the analysis or export fails.
pub fn analyze_program(mode: ReverseOutputMode, target_bytecode: String, labeling: bool) -> Result<()> {
    // Mocking a loader & create an executable
    let loader = Arc::new(BuiltinProgram::new_loader(Config {
        enable_instruction_tracing: true,
        enable_symbol_and_section_labels: labeling,
        ..Config::default()
    }));
    let mut file = File::open(Path::new(&target_bytecode)).unwrap();
    let mut elf = Vec::new();
    file.read_to_end(&mut elf).unwrap();
    let program = elf.clone();
    let executable = Executable::<TestContextObject>::from_elf(&elf, loader).map_err(|err| format!("Executable constructor failed: {err:?}")).unwrap();

    // Perform analysis on the executable (e.g., necessary for disassembly, control flow graph, etc..).
    let mut analysis = Analysis::from_executable(&executable).unwrap();

    // Used to track all immediate datas in order to create a table with their possible associated values
    let mut imm_tracker = ImmediateTracker::new(program.len());
    let imm_tracker_wrapped = Some(&mut imm_tracker);

    match mode {
        ReverseOutputMode::Disassembly(path) => {
            let _ = disassemble_wrapper(&program, &mut analysis, imm_tracker_wrapped, &path);
        }
        ReverseOutputMode::ControlFlowGraph(path) => {
            export_cfg_to_dot(&program, &mut analysis, &path)?;
        }
        ReverseOutputMode::DisassemblyAndCFG(path) => {
            let _ = disassemble_wrapper(&program, &mut analysis, imm_tracker_wrapped, &path);
            export_cfg_to_dot(&program, &mut analysis, &path)?;
        }
        ReverseOutputMode::DisassAndRustEquivalent(path) => {
            println!("Rust equivalent generation is not implemented yet.");
        }
    }
    Ok(())
}

/// Integration tests for the `analyze_program` function using real bytecode inputs.
#[cfg(test)]
mod tests {
    use super::*;

    /// Tests disassembly and CFG generation on a standard bytecode.
    #[test]
    fn test() {
        let _ = analyze_program(
            ReverseOutputMode::DisassemblyAndCFG("test_cases/base_sbf_addition_checker/out1/".to_string()),
            "test_cases/base_sbf_addition_checker/bytecodes/addition_checker.so".to_string(),
            true
        );
    }

    /// Tests disassembly and CFG generation on a SBF program.
    #[test]
    fn test2() {
        let _ = analyze_program(
            ReverseOutputMode::DisassemblyAndCFG("test_cases/base_sbf_addition_checker/out2/".to_string()),
            "test_cases/base_sbf_addition_checker/bytecodes/addition_checker_sbpf_solana.so".to_string(),
            false
        );
    }
}
