use std::{collections::{HashMap, HashSet}, fs, path::Path, time::Duration};
use log::debug;
use regex::Regex;
use serde::{Serialize, Deserialize};
use indicatif::{ProgressBar, ProgressIterator, ProgressStyle};

#[derive(Debug, Deserialize)]
struct Config {
    functions: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct ClusterCache {
    clusters: HashMap<String, String>, // cluster_id -> full block
}

fn load_or_build_cluster_cache(full_dot: &str) -> std::io::Result<ClusterCache> {
    let cache_dir = Path::new(".solazy_cache");
    let cache_path = cache_dir.join("clusters.json");

    if cache_path.exists() {
        let json = fs::read_to_string(&cache_path)?;
        let clusters: ClusterCache = serde_json::from_str(&json)?;
        debug!("Loaded cluster cache from {:?}", cache_path);
        Ok(clusters)
    } else {
        debug!("No cache found. Loading requested clusters & saving it in cluster cache...");

        let mut map = HashMap::new();
        let re = Regex::new(r"(?s)subgraph cluster_(\d+)\s*\{.*?\}").unwrap();

        let spinner = ProgressBar::new_spinner();
        spinner.set_message("Regexing & capturing requested clusters from 'full' .dot file...");
        spinner.set_style(ProgressStyle::default_spinner()
            .tick_strings(&["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"])
            .template("{spinner} {msg}")
            .unwrap());
        spinner.enable_steady_tick(Duration::from_millis(50));
        
        for cap in re.captures_iter(full_dot) {
            let cluster_id = cap[1].to_string();
            let full_block = cap[0].to_string();
            map.insert(cluster_id, full_block);
        }

        spinner.finish_using_style();

        let cluster_cache = ClusterCache { clusters: map };

        fs::create_dir_all(cache_dir)?;
        fs::write(&cache_path, serde_json::to_string_pretty(&cluster_cache)?)?;
        debug!("Cluster cache saved to {:?}", cache_path);

        Ok(cluster_cache)
    }
}

fn is_valid_edge_line(line: &str) -> bool {
    line.contains(" -> {") && !line.contains("style=dotted")
}

fn extract_cleaned_edge<'a>(
    line: &'a str,
    present_lbbs: &HashSet<String>,
    lbb_in_rhs_re: &Regex,
) -> Option<String> {
    let (lhs, rhs) = line.split_once("->")?;
    let src = lhs.trim();
    if !present_lbbs.contains(src) {
        return None;
    }

    let rhs_trimmed = rhs.trim();
    if rhs_trimmed.starts_with('{') && rhs_trimmed.ends_with(';') {
        let inner = &rhs_trimmed[1..rhs_trimmed.len() - 2]; // remove '{' and '};'
        let filtered: Vec<&str> = lbb_in_rhs_re
            .find_iter(inner)
            .map(|m| m.as_str())
            .filter(|lbb| present_lbbs.contains(*lbb))
            .collect();

        if !filtered.is_empty() {
            return Some(format!("{} -> {{{}}};", src, filtered.join(" ")));
        }
    }

    None
}

/// Modifies a reduced `.dot` control flow graph by adding specific function subgraphs
/// and corresponding intra-graph edges from a full `.dot` file.
///
/// This allows the user to focus the visualization on a smaller set of functions
/// while reintroducing certain clusters of interest for deeper analysis.
///
/// # Arguments
///
/// * `json_path` - Path to the JSON configuration file specifying function cluster IDs to restore.
/// * `reduced_path` - Path to the reduced `.dot` file generated by `--reduced` (or `--only-entrypoint`).
/// * `full_path` - Path to the full `.dot` file used as a reference for missing subgraphs and edges.
///
/// # Returns
///
/// An updated `.dot` file prefixed with `updated_` containing:
/// - Re-inserted `subgraph cluster_x { ... }` blocks.
/// - New edges where both endpoints are already present in the reduced graph.
///
/// # JSON Format Example
///
/// ```json
/// {
///   "functions": [ "10", "42", "58" ]
/// }
/// ```
///
/// # Behavior
///
/// - Clusters (subgraphs) from the full DOT are added if they are not already in the reduced version.
/// - Edges are only reinserted if both their source and all destination nodes are already present.
/// - The result is saved to `updated_<reduced_path>`.
///
/// # Errors
///
/// Returns an `std::io::Error` if any file operations fail, or if JSON is malformed.
pub fn editor_add_functions<P: AsRef<Path> + ToString>(
    json_path: P,    // path to config file (.json)
    reduced_path: P, // path to reduced .dot
    full_path: P,    // path to full .dot
) -> std::io::Result<()> {
    let json_content = std::fs::read_to_string(&json_path)?;
    let config: Config = serde_json::from_str(&json_content)?;
    let requested_clusters: HashSet<String> = config.functions.iter().cloned().collect();

    let mut reduced_dot = std::fs::read_to_string(&reduced_path)?;
    let full_dot = std::fs::read_to_string(&full_path)?;

    debug!("Adding requested subgraphs...");
    let cluster_cache = load_or_build_cluster_cache(&full_dot)?;

    // Add requested subgraphs if not already in reduced
    for cluster_id in requested_clusters.iter().progress() {
        if let Some(block) = cluster_cache.clusters.get(cluster_id) {
            if !reduced_dot.contains(&format!("cluster_{}", cluster_id)) {
                if let Some(pos) = reduced_dot.rfind('}') {
                    reduced_dot.insert_str(pos, &format!("\n{}\n", block));
                }
            }
        }
    }

    // Extract all present basic blocks in reduced dot
    let mut present_lbbs = HashSet::new();
    let lbb_re = Regex::new(r"\b(lbb_\d+)\b").unwrap();
    for cap in lbb_re.captures_iter(&reduced_dot) {
        present_lbbs.insert(cap[1].to_string());
    }

    let mut new_edges = Vec::new();
    let reduced_lines: HashSet<&str> = reduced_dot.lines().collect();
    let lbb_in_rhs_re = Regex::new(r"\blbb_\d+\b").unwrap();

    // Process full dot line-by-line to find new edges
    debug!("Processing for new edges...");
    for line in full_dot.lines().collect::<Vec<_>>().iter().progress() {
        if reduced_lines.contains(*line) {
            continue;
        }

        if is_valid_edge_line(line) {
            if let Some(cleaned_line) = extract_cleaned_edge(line, &present_lbbs, &lbb_in_rhs_re) {
                new_edges.push(cleaned_line);
            }
        }
        
    }

    // Inject new edges before the last closing brace
    if let Some(pos) = reduced_dot.rfind('}') {
        reduced_dot.insert_str(pos, &format!("\n{}\n", new_edges.join("\n")));
    }

    let input_path = Path::new(reduced_path.as_ref());
    let parent = input_path.parent().unwrap_or_else(|| Path::new("."));
    let filename = input_path.file_name().unwrap_or_default();

    let updated_filename = format!("updated_{}", filename.to_string_lossy());
    let out_path = parent.join(updated_filename);

    std::fs::write(&out_path, reduced_dot)?;
    debug!("Updated file saved to {:?}", out_path);

    Ok(())
}


#[test]
fn test() -> Result<(), Box<dyn std::error::Error>> {
    editor_add_functions(
        "src/dotting/functions.json",
        "src/dotting/cfg_reduced.dot",
        "src/dotting/cfg.dot"
    )?;
    Ok(())
}
